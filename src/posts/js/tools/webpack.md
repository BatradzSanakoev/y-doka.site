---
title: "Webpack, краткий обзор"
name: webpack
author: kamyshev
co-authors:
designers:
contributors:
summary:
  - webpack
  - вебпак
  - бандлер
  - bundler
---

## Кратко

В современном мире уже не встретишь проекта, где тот код который пишут разработчики напрямую бы отправлялся клиентам — все приложения проходят через [этап сборки](/js/tools/bundlers). В мире JS существует довольного много разных сборщиков, но самый популярный — Webpack.

Webpack — это легко расширяемый инструмент, с помощью сторонних пакетов можно заставить его делать практически что угодно. А благодаря мощному API при необходимости можно написать решение под свой уникальный случай.

## Как пользоваться

### Конфигурация

В базовом случае использовать Webpack довольно просто. Представим, что в нашем приложении есть файл с функциями, необходимыми для работы:

```jsx
// application.js

function sayHello() {
  console.log('Hello!');
}

function sayBye() {
  console.log('Bye!');
}

// экспортируем эти функции, чтобы воспользоваться ими в друго месте
export { sayHello, sayBye };
```

Теперь создадим JS-файл, который будет использоваться как входная точка и вызовем в нем функции приложения:

```jsx
// index.js

import { sayHello, sayBye } from './application';

sayHello();
sayBye();
```

Настроим Webpack, чтоб собрать единый файл с кодом приложения. Для начала следует добавить его в список зависимостей приложения:

```jsx
npm install --dev webpack webpack-cli
```

- `webpack` — основная зависимость, в которой храниться весь код, нужный для работы бандлера;
- `webpack-cli` (Webpack Command Line Interface) — небольшая обертка, которая помогает удобно и просто запускать Webpack из командной строки.

Теперь достаточно создать простой конфигурационный файл:

```jsx
// webpack.config.js

// path — встроенный в Node.js модуль
const path = require('path');

module.exports = {
  // указываем путь до входной точки
  entry: './src/index.js',
  // описываем куда следует поместить результат работы
  output: {
    // путь до директории (важно использовать path.resolve)
    path: path.resolve(__dirname, 'dist'),
    // имяфайла
    filename: 'bundle.js'
  }
};
```

Почти готово, осталось только добавить скрипт для сборки в `package.json` и вызвать его:

```json
// package.json
{
  // ...
  "scripts": {
    // ...
    "build": "webpack",
    // ...
  },
  // ...
}
```

```json
npm run build
```

После выполнения, в директории `dist` окажется файл `bundle.js`, который уже можно подключать на страницу в браузере.

В корне проекта нужно создать файл `index.html` и добавить в него следующее содержимое:

```html
<!doctype html>
<html>
  <head>
    ...
  </head>
  <body>
    ...
    <script src="./dist/bundle.js"></script>
  </body>
</html>
```

Если открыть этот файл в браузере, то в консоли появится приветствие и прощание.

### Отслеживание изменений

После внесения каждой правки заново запускать сборку не очень удобно. Во-первых, придётся каждый раз писать команду в терминале. Во-вторых, полная сборка больших проектов может занимать десятки минут и каждый раз тратить столько времени просто расточительно.

Для решения этой проблемы можно воспользоваться режимом инкрементальной сборки, когда Webpack отслеживает изменения файлов с исходным кодов и автоматически собирает те части, которые изменились.

Добавим новую команду в `package.json`:

```json
// package.json
{
  // ...
  "scripts": {
    // ...
    "build": "webpack",
    "watch": "webpack --watch",
    // ...
  },
  // ...
}
```

Теперь достаточно открыть файл `index.html` в браузере и обновлять страницу после сохранения файлов с исходным кодом.

Для большего удобства можно воспользоваться пакетом [webpack-dev-server](https://webpack.js.org/guides/development/#using-webpack-dev-server).

## Как понять

Webpack — невероятно мощный инструмент, в первую очередь за счёт своей расширяемости. В базовом случае он только собирает несколько JS-файлов в один, но с помощью лоадеров и плагинов можно сильно изменить функциональность этого инструмента.

Обратная стороны расширяемости Webpack — сложность его конфигурации. В больших проектах файл с настройками сборки может занимать тысячи строк. Часто такую конфигурацию разбивают на несколько файлов, чтобы ее было проще читать.

### Лоадеры

Лоадер — это функция, которая принимает содержимое какого-то файла и должна вернуть изменённое содержимое.

Например, `ts-loader` превратит любой TypeScript-код в обыкновенный JavaScript-код.

Для Webpack написано огромное число лоадеров — для работы со стилями, разными языками, для обработки изображений и много других. Вот несколько, которые можно встретить почти в любом проекте:

- `style-loader` — позволяет импортировать CSS-файлы и внедряет стили в DOM;
- `css-loader` — позволяет работать с `@import` и `url()` внутри CSS;
- `babel-loader` — преобразует JavaScript для разных браузеров, позволяет писать код на современном JS, но исполнять его даже в старых браузерах.

Чтобы добавить новый лоадер, нужно расширить файл `webpack.config.js`:

```jsx
// webpack.config.js

module.exports = {
  // ...
  // в этом массиве будут перечислены все примяемые лоадеры
  module: {
    rules: [
      // ...
      {
        // это правило будет применяться ко всем файлам,
        // имя которых подойдет под это регулярное выражение
        test: /\.css$/,
        // список лоадеров, которые применяться к файлу
        use: [
          { loader: 'style-loader' },
          {
            loader: 'css-loader',
            // лоадеру можно передать параметры
            options: { modules: true },
          },
        ],
      },
      // ...
    ],
    // ...
  },
  // ...
};
```

### Плагины

Плагин — невероятно мощный способ расширить или изменить функциональность Webpack. Если лоадер ограничен только одной функцией (он принимает содержимое файла и должен вернуть изменённое содержимое), то плагин может делать все что угодно

Для Webpack написано огромное число плагинов — для работы со стилями, улучшения опыта разработки и упрощения жизни инженеров, для автоматизации рутинных операций и много других. Вот несколько, которые можно встретить почти в любом проекте:

- `MiniCssExtractPlugin` — по умолчанию все стили, которые обработал Webpack попадают в JS-файл и потом вставляются в тег `style`, этот плагин извлекает все стили в отдельный CSS-файл, которые можно подключить к странице через тег `link`;
- `HotModuleReplacementPlugin` — позволяет делать изменения в коде и видеть изменения в браузере без полной перезагрузки страницы, это делает разработку более кофмортной;
- `CompressionWebpackPlugin` — сжимает все ресурсы, сгенерированные Webpack, чтобы передавать пользователям по сети меньший объём данных.

Чтобы добавить новый плагин в сборку, нужно расширить файл `webpack.config.js`:

```jsx
// webpack.config.js

// Webpack предоставляет несколько плагинов в основном пакете
const { ProgressPlugin } = require('webpack');

module.exports = {
  // ...
  plugins: [
    // при сборке этот плагин будет отображать прогресс в консоле
    new ProgressPlugin(),
  ],
  // ...
}
```
